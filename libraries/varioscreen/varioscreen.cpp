#include <varioscreen.h>
#include <Arduino.h>
//#include <avr\dtostrf.h>
#include <DebugConfig.h>

/* http://javl.github.io/image2cpp/ */

#include <imglib/gridicons_sync.h>


/*
    void drawPixel(int16_t x, int16_t y, uint16_t color);
    void fillScreen(uint16_t color); // 0x0 black, >0x0 white, to buffer
    void update(void);    // to buffer, may be cropped, drawPixel() used, update needed, old signature kept
    void  drawBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t color);
    // to buffer, may be cropped, drawPixel() used, update needed, new signature, mirror default for example bitmaps
    void  drawBitmap(const uint8_t *bitmap, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color, bool mirror = true);
    // to full screen, filled with white if size is less, no update needed
    void drawBitmap(const uint8_t *bitmap, uint32_t size); 
    void drawBitmap(const uint8_t *bitmap, uint32_t size, bool using_partial_update);
    void eraseDisplay(bool using_partial_update = false);    // partial update
    void updateWindow(uint16_t x, uint16_t y, uint16_t w, uint16_t h, bool using_rotation = true);
    // paged drawing, for limited RAM, drawCallback() is called GxGDEP015OC1_PAGES times
    // each call of drawCallback() should draw the same
	virtual void setRotation(uint8_t r);
	virtual void invertDisplay(boolean i);

    drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color),
    drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color),
    fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color),

    drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color),
    drawCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername, uint16_t color),
    fillCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color),
	fillCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername,int16_t delta, uint16_t color),
    drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color),
    fillTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color),
    drawRoundRect(int16_t x0, int16_t y0, int16_t w, int16_t h,  int16_t radius, uint16_t color),
    fillRoundRect(int16_t x0, int16_t y0, int16_t w, int16_t h,  int16_t radius, uint16_t color),
    drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color),
    drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color, uint16_t bg),
    drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h, uint16_t color),
    drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h, uint16_t color, uint16_t bg),
    drawXBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color),
    drawGrayscaleBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h),
    drawGrayscaleBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h),
    drawGrayscaleBitmap(int16_t x, int16_t y, const uint8_t bitmap[], const uint8_t mask[], int16_t w, int16_t h),
    drawGrayscaleBitmap(int16_t x, int16_t y, uint8_t *bitmap, uint8_t *mask, int16_t w, int16_t h),
    drawRGBBitmap(int16_t x, int16_t y, const uint16_t bitmap[],   int16_t w, int16_t h),
    drawRGBBitmap(int16_t x, int16_t y, uint16_t *bitmap,   int16_t w, int16_t h),
    drawRGBBitmap(int16_t x, int16_t y,  const uint16_t bitmap[], const uint8_t mask[], int16_t w, int16_t h),
    drawRGBBitmap(int16_t x, int16_t y,  uint16_t *bitmap, uint8_t *mask, int16_t w, int16_t h),
    drawChar(int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size),
    setCursor(int16_t x, int16_t y),
    setTextColor(uint16_t c),
    setTextColor(uint16_t c, uint16_t bg),
    setTextSize(uint8_t s),
    setTextWrap(boolean w),
    cp437(boolean x=true),
    setFont(const GFXfont *f = NULL),
    getTextBounds(char *string, int16_t x, int16_t y, int16_t *x1, int16_t *y1, uint16_t *w, uint16_t *h),
    getTextBounds(const __FlashStringHelper *s, int16_t x, int16_t y, int16_t *x1, int16_t *y1, uint16_t *w, uint16_t *h);
	
	size_t print(const __FlashStringHelper *);
    size_t print(const String &);
    size_t print(const char[]);
    size_t print(char);
    size_t print(unsigned char, int = DEC);
    size_t print(int, int = DEC);
    size_t print(unsigned int, int = DEC);
    size_t print(long, int = DEC);
    size_t print(unsigned long, int = DEC);
    size_t print(double, int = 2);
    size_t print(const Printable&);

    size_t println(const __FlashStringHelper *);
    size_t println(const String &s);
    size_t println(const char[]);
    size_t println(char);
    size_t println(unsigned char, int = DEC);
    size_t println(int, int = DEC);
    size_t println(unsigned int, int = DEC);
    size_t println(long, int = DEC);
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

	
*/
#define VARIOSCREEN_DOT_WIDTH 6
#define VARIOSCREEN_DIGIT_WIDTH 11


/**********/
/* screen */
/**********/

void VarioScreen::begin(void)
{
#ifdef SCREEN_DEBUG
	SerialPort.println("init");	
#endif //SCREEN_DEBUG

  init(115200);
	
//  setRotation(2);

#ifdef SCREEN_DEBUG
	SerialPort.println("fillScreen");	
#endif //SCREEN_DEBUG

  fillScreen(GxEPD_WHITE);
	
#ifdef SCREEN_DEBUG
	SerialPort.println("setTextColor");	
#endif //SCREEN_DEBUG
	
  setTextColor(GxEPD_BLACK);
	
#ifdef SCREEN_DEBUG
	SerialPort.println("update");	
#endif //SCREEN_DEBUG
	
  update();  

/*  updateWindow(0, 0, GxEPD_WIDTH, GxEPD_HEIGHT, false);  
  while (GetState() != STATE_OK) {
    updateWindow(0, 0, GxEPD_WIDTH, GxEPD_HEIGHT, false);
  }*/
}

// Pass string and a cursor position, returns UL corner and W,H.
/*void VarioScreen::getTextBounds(char *str, int16_t x, int16_t y,
        int16_t *x1, int16_t *y1, uint16_t *w, uint16_t *h) {
    uint8_t c; // Current character

	int16_t tmpx, tmpy;
	tmpx = x;
	tmpy = y;
//    *x1 = x;
//    *y1 = y;
    *x1 = tmpx;
    *y1 = tmpy;	
    *w  = *h = 0;

    int16_t minx = _width, miny = _height, maxx = -1, maxy = -1;

    while((c = *str++))
//        charBounds(c, &x, &y, &minx, &miny, &maxx, &maxy);
        charBounds(c, &tmpx, &tmpy, &minx, &miny, &maxx, &maxy);

 #ifdef SCREEN_DEBUG
    SerialPort.print("x - y  : ");
	SerialPort.print(x);
    SerialPort.print("  -  ");
    SerialPort.println(y);

    SerialPort.print("mixx - mixy  : ");
	SerialPort.print(minx);
    SerialPort.print("  -  ");
    SerialPort.println(miny);

    SerialPort.print("maxx - maxy  : ");
    SerialPort.print(maxx);
    SerialPort.print("  -  ");
    SerialPort.println(maxy);
#endif //SCREEN_DEBUG
	
    if(maxx >= minx) {
        *x1 = minx-1;
        *w  = maxx - minx + 1;
    }
    if(maxy >= miny) {
        *y1 = miny-1;
        *h  = maxy - miny + 1;
    }

//	*x1 = minx;
//	*w  = maxx-minx;
//	*y1 = miny;
//	*h  = maxy-miny;
}*/

void VarioScreen::updateScreen (void)
{
	updateWindowNL(0, 0, GxEPD_WIDTH, GxEPD_HEIGHT, false);
}


/*void VarioScreen::clearScreen(void) 
{
  eraseDisplay();	
}*/

/*void VarioScreen::beginClear(void) {
  clearingStep = 0;
}

bool VarioScreen::clearStep(void) {

  /* check if clear is needed *
  if( clearingStep == LCDHEIGHT ) {
    return false;
  }

  /* clear one line *

  /* next *
  clearingStep++;
  return true;
}*/

/*****************************************/
/*  methods common to all screen objects */
/*****************************************/
#define display_needed() (state & 0x01)
#define display_done() state &= ~(0x01)
#define setDisplayFlag() state |= (0x01)

bool VarioScreenObject::update(void) {

  display();
 /* if( display_needed() ) {
    display();
    display_done();
    return true;
  }

  return false;*/
}

void VarioScreenObject::reset(void) {
  setDisplayFlag();
}

/* digit */
#define MAX_CHAR_IN_LINE 7

void ScreenDigit::setValue(double Value) {

  /* build digit and check changes */
  oldvalue=value;
  value=Value;
  reset();
}
 
 int ScreenDigit::digitsBe4Decimal(double number)
{
  int cnt = 1;  // Always has one digit

  // Count -ve sign as one digit
  if(number < 0.0) {
    cnt++;
    number = -number;
  }

  // Count the number of digits beyond the 1st, basically, the exponent.
  while(number >= 10.0) {
    number /= 10;
    cnt++;
  }
  return cnt;
}


char * ScreenDigit::dtostrf2(double number, signed char width, unsigned char prec, char *s, boolean zero) 
{
    char *out;
    unsigned long long integer;
    double fraction, rounding;
    int digit, before, i;
    int delta;

    if (isnan(number)) {
        strcpy(s, "nan");
        return s;
    }
    if (isinf(number)) {
        strcpy(s, "inf");
        return s;
    }

    // rounding up to the precision
    rounding = 0.5;
    for (i = 0; i < prec; ++i)
        rounding /= 10.0;

    if (number < 0.0)
        number -= rounding;
    else
        number += rounding;

    out = s;
    before = digitsBe4Decimal(number);

    // check if padding is required
    if (width < 0) {
        delta = (-width) - (before + prec + 1);
        for (i = 0; i < delta; ++i) *out++ = ' ';
        width = 0;
    }

#ifdef SCREEN_DEBUG
    SerialPort.print("number  : ");
    SerialPort.print(number);
	SerialPort.print(" --  width  : ");
    SerialPort.print(width);
	SerialPort.print("  --  zero :");
    SerialPort.println(zero);
#endif //SCREEN_DEBUG
	
    // check if padding is required
    if ((width > 0) && (zero > 0)) {
        delta = width - (before + prec);
   	    if (prec > 0) delta -= 1; 
		if ((number < 0.0) ||  (plusDisplay)) delta -= 1; 
#ifdef SCREEN_DEBUG
		SerialPort.print("delta  : ");
        SerialPort.println(delta);
#endif //SCREEN_DEBUG
        for (i = 0; i < delta; ++i) {if (zero) {*out++ = '0';}}
    }

    // Handle negative numbers
    if (number < 0.0) {
      *out = '-';
      number = -number;
    }
	else if (plusDisplay) {
        *out = '+';
        ++out;		
	}

    // seperate integral and fractional parts
    integer = (unsigned long long) number;
    fraction = (double) (number - integer);

    // generate chars for each digit of the integral part
    i = before;
    while (integer >= 10) {
        digit = integer % 10;
        out[(i--) - 1] = '0' + digit;
        integer /= 10;
    }

    out[i - 1] = '0' + integer;
    out += before;

    if (prec) {
        // generate chars for each digit of the fractional part
        *out++ = '.';
        for (i = 0; i < prec; ++i) {
            fraction *= 10.0;
            digit = ((unsigned long long) fraction) % 10;
            *out++ = (char) ('0' + digit);
        }
    }


    *out = 0;
    return s;
}


void ScreenDigit::display() {

  /***************/
  /* build digit */
  /***************/

  //normalise value
//  char tmpdigitCharacters[MAX_CHAR_IN_LINE];
  char digitCharacters[MAX_CHAR_IN_LINE];
   
//  screen.setFont(&FreeSansBold12pt7b);
  screen.setFont(&FreeSansBold12pt7b);
  screen.setTextSize(2);

  int16_t box_x = anchorX;
  int16_t box_y = anchorY;
  uint16_t w, h, w1, h1;
  int16_t box_w, box_w1; 
  int16_t box_h, box_h1; 

 // dtostrf(value,width,precision,tmpdigitCharacters);
  dtostrf2(value,width,precision,digitCharacters,zero);
//  dtostrf2(oldvalue,width,precision,tmpdigitCharacters,zero);
//  dtostrf2(value,4,1,digitCharacters,false,false);
  /*if (plusDisplay) {
	  if (value >=0) {
		sprintf(digitCharacters, "+%s", tmpdigitCharacters);  
	  }
	  else {
		sprintf(digitCharacters, "-%s", tmpdigitCharacters);  		  
      }
  }
  
  if (strlen(digitCharacters) > 
  if (rightAlign) {
	  while (strlen(digitCharacters
  }*/
 
 /* int i=0;
  while( i < strlen(digitCharacters)) { tmpdigitCharacters[i++] = '0'; }
  tmpdigitCharacters[i] = 0; 

  SerialPort.print(" tmpdigit : ");
  SerialPort.println(tmpdigitCharacters);*/

#ifdef SCREEN_DEBUG
  SerialPort.print("digit value : ");
  SerialPort.println(value);

  SerialPort.print("digit oldvalue : ");
  SerialPort.println(oldvalue);
  
  if (leftAlign) SerialPort.println("leftAlign");
  else 			 SerialPort.println("rightAlign");
	  
  SerialPort.print(digitCharacters);
  SerialPort.print("-- X : ");
  SerialPort.print(box_x);
  SerialPort.print("-- Y: ");
  SerialPort.print(box_y);
  SerialPort.print("-- width : ");
  SerialPort.print(width);
  SerialPort.print("-- precision :  ");
  SerialPort.println(precision);
#endif //SCREEN_DEBUG
  
//  screen.getTextBounds(digitCharacters, box_x, box_y, &box_w, &box_h, &w, &h);
  screen.getTextWidth(digitCharacters, &w, &h);
//  screen.getTextBounds(tmpdigitCharacters, box_x, box_y, &box_w1, &box_h1, &w1, &h1);
  
//  if (h1 > h) {h = h1;}
//  if (w1 > w) {w = w1;}
  
#ifdef SCREEN_DEBUG
/*  SerialPort.print("X : ");
  SerialPort.println(box_x);
  SerialPort.print("Y : ");
  SerialPort.println(box_y);
  SerialPort.print("X new : ");
  SerialPort.println(box_w);
  SerialPort.print("Y new : ");
  SerialPort.println(box_h);*/
  SerialPort.print("W : ");
  SerialPort.println(w);
  SerialPort.print("H : ");
  SerialPort.println(h);
#endif //SCREEN_DEBUG
  
/*  if (leftAlign) {
	if ((box_x+w1+6) > 200)  
      screen.fillRect(box_x, box_h-3, 200-box_x, h1+3, GxEPD_WHITE);
    else
      screen.fillRect(box_x, box_h-3, w1+6, h1+3, GxEPD_WHITE);
    screen.setCursor(box_x, box_y);
    screen.print(digitCharacters);
  }
  else {
		if ((box_x-(w1+6)) > 0) { 
#ifdef SCREEN_DEBUG
			SerialPort.print("right align > 0");
#endif //SCREEN_DEBUG
 
      screen.fillRect(box_x-w1, box_h-3, 200-box_x, h1+3, GxEPD_WHITE);
		}
		else {
      screen.fillRect(box_x-w1, box_h-3, w1+6, h1+3, GxEPD_WHITE);
		}

//  screen.drawRect(box_x-w, box_h+1, w+1, h, GxEPD_BLACK);
    screen.setCursor(box_x-w-1, box_y);
    screen.print(digitCharacters);
//  screen.updateWindow(box_w, box_h, w+box_w, h, true);	  
  }*/
	
  if (leftAlign) {
	
#ifdef SCREEN_DEBUG
			SerialPort.println("left align");
#endif //SCREEN_DEBUG
	
#ifdef SCREEN_DEBUG
		SerialPort.print("oldX : ");
		SerialPort.println(oldx);
		SerialPort.print("oldY : ");
		SerialPort.println(oldy);
		SerialPort.print("oldW : ");
		SerialPort.println(oldw);
		SerialPort.print("oldH : ");
		SerialPort.println(oldh);
#endif //SCREEN_DEBUG
	
		if ((oldw != 0) && (oldh != 0)) {
			screen.fillRect(oldx, oldy, oldw, oldh, GxEPD_WHITE);
		}	
	
	  
    screen.setCursor(box_x, box_y);
    screen.print(digitCharacters);
		
	} else {

#ifdef SCREEN_DEBUG
			SerialPort.println("right align");
#endif //SCREEN_DEBUG
	
#ifdef SCREEN_DEBUG
		SerialPort.print("oldX : ");
		SerialPort.println(oldx);
		SerialPort.print("oldY : ");
		SerialPort.println(oldy);
		SerialPort.print("oldW : ");
		SerialPort.println(oldw);
		SerialPort.print("oldH : ");
		SerialPort.println(oldh);
#endif //SCREEN_DEBUG
	
		if ((oldw != 0) && (oldh != 0)) {
			screen.fillRect(oldx, oldy, oldw, oldh, GxEPD_WHITE);
		}	
	
	  box_x = box_x - w;
		
    screen.setCursor(box_x, box_y);
    screen.print(digitCharacters);
	}
 
 oldx = box_x;
 oldy = box_y;
 oldw = w;
 oldh = h;
}

void MUnit::display() {
  screen.setFont(&FreeSansBold9pt7b);
  screen.setTextSize(2);
  screen.setCursor(posX, posY);
  screen.print('m');
}



/*{B000000111100001111000000,
B000001111110011111100000,
B000011100001110000110000,
B000011000001100000110000,
B000011000001100000110000,
B000011000001100000110000,
B000011000001100000110000,
B000011000001100000110000,
B000011000001100000110000,
B000000000000000000000000,
B011111111111111111111110,
B011111111111111111111110,
B000000000000000000000000,
B000000000111111110000000,
B000000001111111110000000,
B000000001100000000000000,
B000000001100000000000000,
B000000001111111100000000,
B000000000111111110000000,
B000000000000000110000000,
B000000000000000110000000,
B000000001111111110000000,
B000000001111111000000000,
B000000000000000000000000}*/

  // 24 x 24 
const unsigned char msicons[] = { 
 /*   0x03, 0xC3, 0xC0, 
	0x07, 0xE7, 0xE0, 
	0x0E, 0x1C,	0x30, 	
	0x0C, 0x18, 0x30, 	
	0x0C, 0x18, 0x30, 
	0x0C, 0x18, 0x30,
	0x0C, 0x18, 0x30,	
	0x0C, 0x18, 0x30,	
	0x0C, 0x18, 0x30,	
	0x00, 0x00, 0x00, 
	0x3F, 0xFF,	0xFC, 
	0x3F, 0xFF, 0xFC, 
	0x00, 0x00, 0x00, 
	0x00, 0x7F, 0x80, 	
	0x00, 0xFF, 0x80,	
	0x00, 0xC0, 0x00,
	0x00, 0xC0, 0x00,
	0x00, 0xFF, 0x00, 	
	0x00, 0x7F,	0x80,
	0x00, 0x01, 0x80, 
	0x00, 0x01, 0x80, 
	0x00, 0xFF, 0x80, 
	0x00, 0xFF, 0x80, 
	0x00, 0x00, 0x00*/
	0x00, 0x00, 0x00,
	0x07, 0xFF, 0xE0,
	0x0F, 0xFF, 0xF0,
	0x0C, 0x18, 0x30,
	0x0C, 0x18, 0x30,
	0x0C, 0x18, 0x30,
	0x0C, 0x18, 0x30,
	0x0C, 0x18, 0x30,
	0x0C, 0x18, 0x30,
	0x00, 0x00, 0x00,
	0x3F, 0xFF,	0xFC, 
	0x3F, 0xFF, 0xFC, 
	0x00, 0x00, 0x00, 
	0x00, 0x7F, 0x80, 	
	0x00, 0xFF, 0x80,	
	0x00, 0xC0, 0x00,
	0x00, 0xC0, 0x00,
	0x00, 0xFF, 0x00, 	
	0x00, 0x7F,	0x80,
	0x00, 0x01, 0x80, 
	0x00, 0x01, 0x80, 
	0x00, 0xFF, 0x80, 
	0x00, 0xFF, 0x80, 
	0x00, 0x00, 0x00
};

/*{B000000000000000000000000,
B000001111111111111100000,
B000011111111111111110000,
B000110000001100000011000,
B000110000001100000011000,
B000110000001100000011000,
B000110000001100000011000,
B000110000001100000011000,
B000110000001100000011000,
B000110000001100000011000,
B000000000000000000000000,
B000000000000000000000000,
B111111111111111111111111,
B111111111111111111111111,
B000000000000000000000000,
B000000000111111000000000,
B000000001100000000000000,
B000000001000000000000000,
B000000001100000000000000,
B000000000111110000000000,
B000000000000011000000000,
B000000000000001000000000,
B000000000000011000000000,
B000000001111110000000000}*/

void MSUnit::display() {
// screen.drawBitmap(msicons, posX, posY, 48, 48, GxEPD_WHITE,false);   //GxEPD_BLACK);
 screen.drawBitmap(msicons, posX, posY, 24, 24, GxEPD_BLACK,false);   //GxEPD_BLACK);
//  screen.drawBitmap(100, 10, gridicons_sync, 24, 24, GxEPD_BLACK);
}

/*{B000000000000000000000000,
B001100001001111111111000,
B001100011011111111111100,
B001100110011000110001100,
B001111100011000110001100,
B001111000011000110001100,
B001101100011000110001100,
B001100110011000110001100,
B001100011011000110001100,
B000000000000000000000000,
B001111111111111111111100,
B001111111111111111111100,
B000000000000000000000000,
B000000001100000000000000,
B000000001100000000000000,
B000000001100000000000000,
B000000001100000000000000,
B000000001111111100000000,
B000000001111111110000000,
B000000001100000110000000,
B000000001100000110000000,
B000000001100000110000000,
B000000001100000110000000,
B000000001100000110000000}*/

  // 24 x 24 
const unsigned char kmhicons[] = { 
    0x00, 0x00, 0x00, 0x30, 0x9F, 0xF8, 0x31, 0xBF,	
	0xFC, 0x33, 0x31, 0x8C, 0x3E, 0x31, 0x8C, 0x3C,
	0x31, 0x8C, 0x36, 0x31, 0x8C, 0x33, 0x31, 0x8C,
	0x31, 0xB1, 0x8C, 0x00, 0x00, 0x00, 0x3F, 0xFF,
	0xFC, 0x3F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00,
	0xC0, 0x00, 0x00, 0xC0, 0x00, 0x00, 0xC0, 0x00,
	0x00, 0xC0, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
	0x00, 0x00, 0xC1, 0x80, 0x00, 0xC1, 0x80, 0x00, 
	0xC1, 0x80, 0x00, 0xC1, 0x80, 0x00, 0xC1, 0x80
};

void KMHUnit::display() {
// screen.drawBitmap(msicons, posX, posY, 48, 48, GxEPD_WHITE,false);   //GxEPD_BLACK);
 screen.drawBitmap(kmhicons, posX, posY, 24, 24, GxEPD_BLACK,false);   //GxEPD_BLACK);
//  screen.drawBitmap(100, 10, gridicons_sync, 24, 24, GxEPD_BLACK);
}

/*  // 48 x 48 
const unsigned char baticons[] = { 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf1, 0xff, 
0xff, 0xff, 0xfe, 0x3f, 0xe7, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xe6, 0xef, 0xff, 0xff, 0xff, 0x9f, 
0xe6, 0x6f, 0xff, 0xff, 0xff, 0x9f, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0x9f, 0xe6, 0x6f, 0xff, 0xff, 
0xff, 0x9f, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0x83, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0x83, 0xe6, 0x6f, 
0xff, 0xff, 0xff, 0xf3, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0xf3, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0xf3, 
0xe6, 0x6f, 0xff, 0xff, 0xff, 0xf3, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0xf3, 0xe6, 0x6f, 0xff, 0xff, 
0xff, 0xf3, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0x83, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0x83, 0xe6, 0x6f, 
0xff, 0xff, 0xff, 0x9f, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0x9f, 0xe6, 0x6f, 0xff, 0xff, 0xff, 0x9f, 
0xe6, 0xef, 0xff, 0xff, 0xff, 0x9f, 0xe7, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xf1, 0xff, 0xff, 0xff, 
0xfe, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};*/


const unsigned char bat0icons[] = { 
 // 'basic1-191_battery_empty-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 
0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xc7, 0xcf, 0xff, 0xff, 0xc3, 
0xcf, 0xff, 0xff, 0xc3, 0xcf, 0xff, 0xff, 0xc3, 0xcf, 0xff, 0xff, 0xc3, 0xcf, 0xff, 0xff, 0xc3, 
0xcf, 0xff, 0xff, 0xc7, 0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xc0, 0x00, 0x00, 0x0f, 
0xc0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char bat1icons[] = { 
 // 'basic1-192_battery_1-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 
0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xcc, 0x7f, 0xff, 0xc7, 0xcc, 0x7f, 0xff, 0xc3, 
0xcc, 0x7f, 0xff, 0xc3, 0xcc, 0x7f, 0xff, 0xc3, 0xcc, 0x7f, 0xff, 0xc3, 0xcc, 0x7f, 0xff, 0xc3, 
0xcc, 0x7f, 0xff, 0xc7, 0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xc0, 0x00, 0x00, 0x0f, 
0xc0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char bat2icons[] = { 
 // 'basic1-193_battery_2-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 
0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xcc, 0x63, 0xff, 0xc7, 0xcc, 0x63, 0xff, 0xc3, 
0xcc, 0x63, 0xff, 0xc3, 0xcc, 0x63, 0xff, 0xc3, 0xcc, 0x63, 0xff, 0xc3, 0xcc, 0x63, 0xff, 0xc3, 
0xcc, 0x63, 0xff, 0xc7, 0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xc0, 0x00, 0x00, 0x0f, 
0xc0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char bat3icons[] = { 
 // 'basic1-194_battery_3-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 
0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xcc, 0x63, 0x1f, 0xc7, 0xcc, 0x63, 0x1f, 0xc3, 
0xcc, 0x63, 0x1f, 0xc3, 0xcc, 0x63, 0x1f, 0xc3, 0xcc, 0x63, 0x1f, 0xc3, 0xcc, 0x63, 0x1f, 0xc3, 
0xcc, 0x63, 0x1f, 0xc7, 0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xc0, 0x00, 0x00, 0x0f, 
0xc0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char bat4icons[] = { 
 // 'basic1-195_battery_full-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 
0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xcc, 0x63, 0x18, 0xc7, 0xcc, 0x63, 0x18, 0xc3, 
0xcc, 0x63, 0x18, 0xc3, 0xcc, 0x63, 0x18, 0xc3, 0xcc, 0x63, 0x18, 0xc3, 0xcc, 0x63, 0x18, 0xc3, 
0xcc, 0x63, 0x18, 0xc7, 0xcf, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0xff, 0xcf, 0xc0, 0x00, 0x00, 0x0f, 
0xc0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char batchargeicons[] = { 
 // 'basic1-196_battery_charging-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xfc, 0x7f, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 
0xff, 0xe0, 0x3f, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xc0, 0xe0, 0x06, 0x1f, 0xc0, 0xc0, 0x0c, 0x0f, 
0xcf, 0xc0, 0x1f, 0xcf, 0xcf, 0xf8, 0x3f, 0xcf, 0xcf, 0xf0, 0x3f, 0xcf, 0xcf, 0xf0, 0x7f, 0xc3, 
0xcf, 0xe0, 0xff, 0xc3, 0xcf, 0xe0, 0xff, 0xc3, 0xcf, 0xe0, 0xff, 0xc3, 0xcf, 0xc0, 0x3f, 0xc3, 
0xcf, 0xc0, 0x7f, 0xc7, 0xcf, 0xf8, 0x7f, 0xcf, 0xcf, 0xf8, 0xff, 0xcf, 0xc0, 0x19, 0xc0, 0x0f, 
0xc0, 0x19, 0x80, 0x0f, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

/* !!! always reset !!! */
void BATLevel::setVoltage(int voltage) {

#ifdef SCREEN_DEBUG
  SerialPort.print("Voltage : ");
  SerialPort.println(voltage);
#endif //SCREEN_DEBUG
  
  /* shift voltage to 16 bit */
  double tmp;
  tmp = (double)voltage / 43;
#ifdef SCREEN_DEBUG
  SerialPort.print("Voltage : ");
  SerialPort.println(tmp);
#endif //SCREEN_DEBUG
  
  uVoltage = (uint16_t)(tmp*100);
//  uVoltage <<= VARIOSCREEN_BAT_MULTIPLIER;
  
  reset();
}

void BATLevel::display(void) {

  /* battery base */

  /* battery level */
 /* uint16_t baseVoltage = base + inc;
  uint8_t pixelCount = 0;*/

#ifdef SCREEN_DEBUG
  SerialPort.print("uVoltage : ");
  SerialPort.println(uVoltage);
#endif //SCREEN_DEBUG
  
  if (uVoltage >= 75)
    screen.drawBitmap(bat4icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  else if (uVoltage >= 50)
    screen.drawBitmap(bat3icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  else if (uVoltage >= 25)
    screen.drawBitmap(bat2icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  else if (uVoltage >= 10)
    screen.drawBitmap(bat1icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  else
    screen.drawBitmap(bat0icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
	  
 /* while( pixelCount < VARIOSCREEN_BAT_PIXEL_COUNT ) {
    if( baseVoltage < uVoltage ) {
      screen.display( 0xff );
    } else {
      screen.display( 0x81 );
    }

    baseVoltage += inc;
    pixelCount++;
  }*/

  /* battery end */
}

/*-----------------------------------------*/
/*              BATTERY                    */
/*-----------------------------------------*/
/*
#define BACKCOLOR 0x18E3
#define BARCOLOR 0x0620
#define SCALECOLOR 0xFFFF

//Analog Measurement Declarations
const int analogIn = A0;
int RawValue = 0;
int LastPercent = 0;
 

void setup() {
  tft.begin();
  tft.fillScreen(BACKCOLOR);
  drawScale(); 
}

void loop(){  
    int newPercent;
    RawValue = analogRead(analogIn);
    newPercent = int((RawValue/1024.0)* 100.0);
    
    if (newPercent != LastPercent){
      drawBar(newPercent);     
    }
     
}

void drawScale(){  
  tft.drawFastVLine(55, 20,100, SCALECOLOR ); // Vertical Scale Line  
  tft.drawFastHLine(47, 20, 8, SCALECOLOR); // Major Division
  tft.drawFastHLine(50, 44, 5, SCALECOLOR); // Minor Division
  tft.drawFastHLine(47, 69, 8, SCALECOLOR); // Major Division
  tft.drawFastHLine(50, 94, 5, SCALECOLOR); // Minor Division
  tft.drawFastHLine(47, 119, 8, SCALECOLOR);  // Major Division
}


void drawBar (int nPer){

  if(nPer < LastPercent){
    tft.fillRect(61, 20 + (100-LastPercent), 30, LastPercent - nPer,  BACKCOLOR);     
  }
  else{
    tft.fillRect(61, 20 + (100-nPer), 30, nPer - LastPercent,  BARCOLOR);
  }    
  LastPercent = nPer;  
  
}
*/

 // 'basic1-094_volume-32'

const unsigned char volume0icons[] = { 
 // 'basic1-096_volume_mute-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 
0xff, 0xe0, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xe0, 0x00, 0xff, 0xff, 
0xe0, 0x00, 0xf9, 0xcf, 0xe0, 0x00, 0xf0, 0x87, 0xe0, 0x00, 0xf8, 0x0f, 0xe0, 0x00, 0xfc, 0x1f, 
0xe0, 0x00, 0xfc, 0x1f, 0xe0, 0x00, 0xf8, 0x0f, 0xe0, 0x00, 0xf0, 0x87, 0xe0, 0x00, 0xf9, 0xcf, 
0xe0, 0x00, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 
0xff, 0xf8, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char volume1icons[] = { 
 // 'basic1-093_volume_low-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 
0xff, 0xe0, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xe0, 0x00, 0xff, 0xff, 
0xe0, 0x00, 0xff, 0xff, 0xe0, 0x00, 0xe7, 0xff, 0xe0, 0x00, 0xf7, 0xff, 0xe0, 0x00, 0xf7, 0xff, 
0xe0, 0x00, 0xf7, 0xff, 0xe0, 0x00, 0xe7, 0xff, 0xe0, 0x00, 0xe7, 0xff, 0xe0, 0x00, 0xff, 0xff, 
0xe0, 0x00, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 
0xff, 0xf8, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char volume2icons[] = { 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 
0xff, 0xe0, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xe0, 0x00, 0xfe, 0xff, 
0xe0, 0x00, 0xfe, 0x7f, 0xe0, 0x00, 0xe6, 0x7f, 0xe0, 0x00, 0xf7, 0x7f, 0xe0, 0x00, 0xf7, 0x7f, 
0xe0, 0x00, 0xf7, 0x7f, 0xe0, 0x00, 0xe7, 0x7f, 0xe0, 0x00, 0xe6, 0x7f, 0xe0, 0x00, 0xfe, 0x7f, 
0xe0, 0x00, 0xfe, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 
0xff, 0xf8, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char volume3icons[] = { 
 // 'basic1-095_volume_loud-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xf8, 0xff, 0x9f, 
0xff, 0xe0, 0xff, 0xdf, 0xff, 0xc0, 0xff, 0xcf, 0xff, 0x80, 0xff, 0xef, 0xe0, 0x00, 0xfe, 0xe7, 
0xe0, 0x00, 0xfe, 0x67, 0xe0, 0x00, 0xe6, 0x77, 0xe0, 0x00, 0xf7, 0x77, 0xe0, 0x00, 0xf7, 0x77, 
0xe0, 0x00, 0xf7, 0x77, 0xe0, 0x00, 0xe7, 0x77, 0xe0, 0x00, 0xe6, 0x77, 0xe0, 0x00, 0xfe, 0x67, 
0xe0, 0x00, 0xfe, 0xe7, 0xff, 0x80, 0xff, 0xef, 0xff, 0xc0, 0xff, 0xcf, 0xff, 0xe0, 0xff, 0x9f, 
0xff, 0xf8, 0xff, 0x9f, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};



/* !!! always reset !!! */
void VOLLevel::setVolume(int Volume) {

  volume=Volume;
 
  reset();
}

void VOLLevel::display(void) {

  if (volume == 0)  screen.drawBitmap(volume0icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  else if (volume < 5) screen.drawBitmap(volume1icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  else if (volume < 9) screen.drawBitmap(volume2icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  else  screen.drawBitmap(volume3icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
}
    
const unsigned char saticons[] = { 
 // 'signal-32'
0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 
0xff, 0xff, 0xff, 0xe0, 
0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 
0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xf8, 0x60, 
0xff, 0xff, 0xf8, 0x60, 0xff, 0xff, 0xf8, 0x60, 0xff, 0xff, 0xf8, 0x60, 0xff, 0xff, 0xf8, 0x60, 
0xff, 0xff, 0xf8, 0x60, 0xff, 0xff, 0xf8, 0x60, 0xff, 0xfc, 0x38, 0x60, 0xff, 0xfc, 0x38, 0x60, 
0xff, 0xfc, 0x38, 0x60, 0xff, 0xfc, 0x38, 0x60, 0xff, 0xfc, 0x38, 0x60, 0xfe, 0x1c, 0x38, 0x60, 
0xfe, 0x1c, 0x38, 0x60, 0x0e, 0x1c, 0x38, 0x60, 0x06, 0x1c, 0x38, 0x60, 0x06, 0x1c, 0x38, 0x60, 
0x06, 0x1c, 0x38, 0x60, 0x0e, 0x1c, 0x38, 0x70, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
  
const unsigned char satfixicons[] = { 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 
0xff, 0xe0, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xe0, 0x00, 0xfe, 0xff, 
0xe0, 0x00, 0xfe, 0x7f, 0xe0, 0x00, 0xe6, 0x7f, 0xe0, 0x00, 0xf7, 0x7f, 0xe0, 0x00, 0xf7, 0x7f, 
0xe0, 0x00, 0xf7, 0x7f, 0xe0, 0x00, 0xe7, 0x7f, 0xe0, 0x00, 0xe6, 0x7f, 0xe0, 0x00, 0xfe, 0x7f, 
0xe0, 0x00, 0xfe, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 
0xff, 0xf8, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

/* !!! always reset !!! */
void SATLevel::setSatelliteCount(uint8_t count) {

  satelliteCount = count;
  reset();
}
  
void SATLevel::display(void) {

  screen.drawBitmap(saticons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);

  uint8_t satelliteBar = satelliteCount;
  if (satelliteBar > 15) satelliteBar = 15;
  satelliteBar /= 3;
  
  screen.fillRect(posX+(satelliteBar*6), posY, 32-(satelliteBar*6), 32, GxEPD_WHITE);
}


const unsigned char recicons[] = { 
 // 'Phone_6-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf0, 0x3f, 0xfc, 0x0f, 0xe0, 0x0f, 0xf0, 0x07, 0xc3, 0x87, 0xe1, 0xc3, 
0x8f, 0xe3, 0xc7, 0xf1, 0x9f, 0xe3, 0xc7, 0xf9, 0x1f, 0xf3, 0xcf, 0xf8, 0x1f, 0xf3, 0xcf, 0xf8, 
0x1f, 0xf3, 0xcf, 0xf8, 0x1f, 0xf3, 0xcf, 0xf8, 0x9f, 0xe3, 0xc7, 0xf9, 0x8f, 0xe3, 0xc7, 0xf1, 
0xc3, 0x87, 0xe1, 0xc3, 0xe0, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char pauseicons[] = { 
 // 'Clock_4-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xf0, 0x0f, 0x0f, 
0xff, 0x80, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x7f, 0xfc, 0x03, 0xc0, 0x3f, 0xf8, 0x1f, 0xf8, 0x1f, 
0xf0, 0x7f, 0xfe, 0x1f, 0xf0, 0xff, 0xff, 0x0f, 0xe1, 0xfe, 0xff, 0x87, 0xe1, 0xfe, 0xff, 0x87, 
0xc3, 0xfe, 0xff, 0xc3, 0xc3, 0xfe, 0xff, 0xc3, 0xc7, 0xfe, 0xff, 0xe3, 0xc7, 0xfe, 0xff, 0xe3, 
0xc7, 0xfc, 0x7f, 0xe3, 0xc7, 0xfc, 0x3f, 0xe3, 0xc7, 0xfc, 0x7f, 0xe3, 0xc7, 0xfc, 0xff, 0xe3, 
0xc7, 0xff, 0xff, 0xe3, 0xc3, 0xff, 0xff, 0xc3, 0xc3, 0xff, 0xff, 0xc7, 0xe1, 0xff, 0xff, 0x87, 
0xe0, 0xff, 0xff, 0x07, 0xf0, 0x7f, 0xfe, 0x0f, 0xf8, 0x3f, 0xfc, 0x1f, 0xfc, 0x0f, 0xf0, 0x3f, 
0xfe, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xf8, 0x1f, 0xff
};

const unsigned char fix1icons[] = { 
 // 'Arrow_46-32'
0xdf, 0xff, 0xff, 0xfb, 0x8f, 0xff, 0xff, 0xf1, 0x07, 0xcf, 0xf3, 0xe0, 0x83, 0x8f, 0xf1, 0xc1, 
0xc1, 0x0f, 0xf0, 0x03, 0xe0, 0x0f, 0xf0, 0x07, 0xf0, 0x0f, 0xf0, 0x0f, 0xf8, 0x0f, 0xf0, 0x1f, 
0xf0, 0x0f, 0xf0, 0x0f, 0xe0, 0x0f, 0xf0, 0x07, 0xc0, 0x0f, 0xf0, 0x03, 0xc0, 0x1f, 0xf8, 0x03, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xc0, 0x1f, 0xf8, 0x03, 0xc0, 0x0f, 0xf0, 0x03, 0xe0, 0x0f, 0xf0, 0x07, 0xf0, 0x0f, 0xf0, 0x0f, 
0xf8, 0x0f, 0xf0, 0x1f, 0xf0, 0x0f, 0xf0, 0x0f, 0xe0, 0x0f, 0xf0, 0x07, 0xc1, 0x0f, 0xf0, 0x83, 
0x83, 0x8f, 0xf1, 0xc1, 0x07, 0xcf, 0xf3, 0xe0, 0x8f, 0xff, 0xff, 0xf1, 0xdf, 0xff, 0xff, 0xfb
};

const unsigned char fix2icons[] = { 
 // 'Fit-To-Screen-32'
0x80, 0x3f, 0xfc, 0x01, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0xff, 0xff, 0x00, 
0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x3f, 0xfc, 0x00, 
0x1c, 0x1f, 0xf8, 0x38, 0x3e, 0x0f, 0xf0, 0x7c, 0xff, 0x0f, 0xf0, 0xff, 0xff, 0x9f, 0xf9, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 
0xff, 0x87, 0xf9, 0xff, 0xff, 0x07, 0xf0, 0xff, 0x3e, 0x0f, 0xf0, 0x7c, 0x1c, 0x1f, 0xf8, 0x38, 
0x00, 0x3f, 0xfc, 0x10, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 
0x00, 0xff, 0xff, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x80, 0x3f, 0xfc, 0x01
};

void RECORDIndicator::stateRECORD(void) {

  unsigned long FreqDuration = millis() - lastFreqUpdate;
  if( FreqDuration > 1000 ) {
      lastFreqUpdate = millis();
	  displayRecord ^= 1;
      reset();
  }
}

void RECORDIndicator::setActifSCAN(void) {

  recordState =  STATE_SCAN;
}  
  
void RECORDIndicator::setActifRECORD(void) {

  recordState = STATE_RECORD;
}

void RECORDIndicator::setActifGPSFIX(void) {

  recordState = STATE_GPSFIX;
}
  
void RECORDIndicator::display(void) {

  if( recordState==STATE_RECORD) {
	  if( displayRecord)
        screen.drawBitmap(recicons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
	  else
	    screen.fillRect(posX, posY, 32, 32, GxEPD_WHITE);
  } else if  (recordState==STATE_GPSFIX) {
      screen.drawBitmap(pauseicons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  } else if (displayRecord) {
      screen.drawBitmap(fix1icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  } else  {
      screen.drawBitmap(fix2icons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
  }
}

const unsigned char trendupicons[] = { 
 // 'Arrow-19-24'
0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xc3, 0xff, 0xff, 0x81, 0xff, 0xff, 0x00, 0xff, 0xfe, 
0x00, 0x7f, 0xfc, 0x24, 0x3f, 0xf8, 0x66, 0x1f, 0xf8, 0xe7, 0x1f, 0xf9, 0xe7, 0x9f, 0xff, 0xe7, 
0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 
0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 
0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff
};

const unsigned char trenddownicons[] = { 
 // 'Arrow-18-24'
0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 
0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 
0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xf9, 0xe7, 0x9f, 0xf8, 0xe7, 0x1f, 
0xf8, 0x66, 0x1f, 0xfc, 0x24, 0x3f, 0xfe, 0x00, 0x7f, 0xff, 0x00, 0xff, 0xff, 0x81, 0xff, 0xff, 
0xc3, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff
};

/* !!! always reset !!! */
void TRENDLevel::stateTREND(int8_t state) {

  trendState = state;
  reset();
}
  
void TRENDLevel::display(void) {


   /* check level and display arrow or blank */
    if( trendState == 1 )  {
	  screen.drawBitmap(trendupicons, posX, posY, 24, 24, GxEPD_WHITE,false);   //GxEPD_BLACK);
    } else if( trendState == -1 ) {  
	  screen.drawBitmap(trenddownicons, posX, posY, 24, 24, GxEPD_WHITE,false);   //GxEPD_BLACK);
    } else {
	  screen.fillRect(posX, posY, 24, 24, GxEPD_WHITE);
    }
}

  // 8 x 24 
const unsigned char doticons[] = { 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

  // 16 x 24 
const unsigned char hicons[] = { 
0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 
0x1C, 0x00, 0x1F, 0xF0, 0x1F, 0xF8, 0x1F, 0xFC, 
0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C,
0x1C, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* time */
void ScreenTime::setTime(uint32_t newTime) {

  for( uint8_t i = 0; i<3; i++) {
    time[i] = (int8_t)(newTime % 100);
    newTime /= 100;
  }
}

void ScreenTime::setTime(int8_t* newTime) {

  for(uint8_t i = 0; i<3; i++) {
    time[i] = newTime[i];
  }
}

void ScreenTime::correctTimeZone(int8_t UTCDrift) {
  
  time[2] += UTCDrift;
  if( time[2] < 0 ) {
    time[2] += 24;
  }
  if( time[2] >= 24 ) {
    time[2] -= 24;
  }
}

int8_t* ScreenTime::getTime(void) {

  return time;
}

/* !!! never reset, only on page change !!! */
void ScreenTime::display(void) {

  screen.fillRect(posX-63, posY-32, 65, 34, GxEPD_WHITE);


  if (dot_or_h == false)
    screen.drawBitmap(hicons, posX-65, posY-24, 16, 24, GxEPD_BLACK,false);   //GxEPD_BLACK);
  else	  
    screen.drawBitmap(doticons, posX-67, posY-26, 16, 24, GxEPD_BLACK,false);   //GxEPD_BLACK);

  hour.setValue(time[2]);
  hour.display();
 //  display h ou dot

  minute.setValue(time[1]);
  minute.display();
 }


void ScreenElapsedTime::setBaseTime(int8_t* time) {

  for(uint8_t i = 0; i<3; i++) {
    baseTime[i] = time[i];
  }
}

void ScreenElapsedTime::setCurrentTime(int8_t* currentTime) {

  /* compute elapsed time */
  int8_t rem = 0;
  int8_t v;
  for(uint8_t i = 0; i<3; i++) {
    v = (currentTime[i] - baseTime[i]) - rem;
    if( v < 0 ) {
      v += 60;
      rem = 1;
    } else {
      rem = 0;
    }
    time[i] = v;
  }
}

  // 24 x 24 
const unsigned char fixgpsicons[] = { 
 // 'location-marker-24'
0xff, 0x81, 0xff, 0xff, 0x00, 0xff, 0xfe, 0x00, 0x7f, 0xfc, 0x00, 0x3f, 0xfc, 0x3c, 0x3f, 0xf8, 
0x7e, 0x1f, 0xf8, 0x7e, 0x1f, 0xf8, 0x7e, 0x1f, 0xf8, 0x7e, 0x1f, 0xf8, 0x3c, 0x1f, 0xf8, 0x00, 
0x1f, 0xfc, 0x00, 0x3f, 0xfc, 0x00, 0x3f, 0xfc, 0x00, 0x3f, 0xfe, 0x00, 0x7f, 0xfe, 0x00, 0x7f, 
0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x81, 0xff, 0xff, 0x81, 0xff, 0xff, 0xc3, 0xff, 0xff, 
0xc3, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff
};

void FIXGPSInfo::setFixGps(void) {
  FixGPS = 	true;
}
  
void FIXGPSInfo::unsetFixGps(void) {
  FixGPS = false;
}

boolean FIXGPSInfo::getFixGps(void) {
  return FixGPS;
}

void FIXGPSInfo::display() {
// screen.drawBitmap(msicons, posX, posY, 48, 48, GxEPD_WHITE,false);   //GxEPD_BLACK);
 if (FixGPS == true) screen.drawBitmap(fixgpsicons, posX, posY, 24, 24, GxEPD_WHITE,false);   //GxEPD_BLACK);
 else                screen.fillRect(posX, posY, 24, 24, GxEPD_WHITE);
  
//  screen.drawBitmap(100, 10, gridicons_sync, 24, 24, GxEPD_BLACK);
}


  // 32 x 32 
const unsigned char usbicons[] = { 
 // 'basic1-197_usb-32'
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xef, 0xff, 
0xff, 0xf7, 0xef, 0xff, 0xff, 0xf7, 0xef, 0xff, 0xff, 0xf5, 0xaf, 0xff, 0xff, 0xf7, 0xef, 0xff, 
0xff, 0xf7, 0xef, 0xff, 0xff, 0xf7, 0xef, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xcf, 0xf3, 0xff, 
0xff, 0xcf, 0xf3, 0xff, 0xff, 0xcf, 0xf3, 0xff, 0xff, 0xcf, 0xf3, 0xff, 0xff, 0xcf, 0xf3, 0xff, 
0xff, 0xcf, 0xf3, 0xff, 0xff, 0xcf, 0xf3, 0xff, 0xff, 0xcf, 0xf3, 0xff, 0xff, 0xcf, 0xf3, 0xff, 
0xff, 0xcf, 0xf3, 0xff, 0xff, 0xcf, 0xe7, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xfc, 0x3f, 0xff, 
0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 
0xff, 0xfe, 0x7f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

void INFOLevel::set(uint8_t value) {
  InfoValue = 	value;
}

void INFOLevel::display() {
// screen.drawBitmap(msicons, posX, posY, 48, 48, GxEPD_WHITE,false);   //GxEPD_BLACK);
 if (InfoValue == INFO_USB) screen.drawBitmap(usbicons, posX, posY, 32, 32, GxEPD_WHITE,false);   //GxEPD_BLACK);
 else                screen.fillRect(posX, posY, 32, 32, GxEPD_WHITE);
}



  // 24 x 24 
const unsigned char bticons[] = { 
 // 'Bluetooth-24'
0xff, 0xc3, 0xff, 0xff, 0x00, 0xff, 0xfe, 0x00, 0x7f, 0xfc, 0x10, 0x3f, 0xfc, 0x18, 0x3f, 0xfc, 
0x1c, 0x3f, 0xfc, 0x1e, 0x3f, 0xfc, 0x1b, 0x3f, 0xfc, 0x9b, 0x3f, 0xfc, 0xde, 0x3f, 0xfc, 0x7c, 
0x3f, 0xfc, 0x38, 0x3f, 0xfc, 0x38, 0x3f, 0xfc, 0x7c, 0x3f, 0xfc, 0xde, 0x3f, 0xfc, 0x9b, 0x3f, 
0xfc, 0x1b, 0x3f, 0xfc, 0x1e, 0x3f, 0xfc, 0x1c, 0x3f, 0xfc, 0x18, 0x3f, 0xfc, 0x00, 0x3f, 0xfe, 
0x00, 0x7f, 0xff, 0x00, 0xff, 0xff, 0xc3, 0xff
};

void BTInfo::setBT(void) {
  bt = 	true;
}
  
void BTInfo::unsetBT(void) {
  bt = false;
}

boolean BTInfo::getBT(void) {
  return bt;
}

void BTInfo::display() {
// screen.drawBitmap(msicons, posX, posY, 48, 48, GxEPD_WHITE,false);   //GxEPD_BLACK);
 if (bt == true) screen.drawBitmap(bticons, posX, posY, 24, 24, GxEPD_WHITE,false);   //GxEPD_BLACK);
 else                screen.fillRect(posX, posY, 24, 24, GxEPD_WHITE);
 //  screen.drawBitmap(100, 10, gridicons_sync, 24, 24, GxEPD_BLACK);
}

/************************/
/* The screen scheduler */
/************************/

void ScreenScheduler::displayStep(void) {

  /* next try to find something to display */
  /* for the current page                  */
#ifdef SCREEN_DEBUG
  SerialPort.print("objectCount  : ");
  SerialPort.println(objectCount);
#endif //SCREEN_DEBUG
  
  uint8_t n = 0;
  while( n != objectCount ) {
 /*   if( displayList[pos].page == currentPage && displayList[pos].actif == true && displayList[pos].object->update() ) {
      return;
    }*/
    if( displayList[pos].page == currentPage && displayList[pos].actif == true) displayList[pos].object->update(); 
	
    /* next */
    pos++;
    if( pos == objectCount) {
      pos = 0;
    }
    n++;
  }
}

int8_t ScreenScheduler::getPage(void) {

  return currentPage;
}

int8_t ScreenScheduler::getMaxPage(void) {

  return endPage;
}

void ScreenScheduler::setPage(int8_t page, boolean force)  {

  /* check if page change is needed */
  if (force == false) {
    if ( page == currentPage ) {
      return;
    }

    /* set the new page */
    currentPage = page;
  }

  /* screen need to by cleared */
//  screen.clearScreen();
 // screen.eraseDisplay();
    screen.fillRect(0, 0, GxEPD_WIDTH, GxEPD_HEIGHT, GxEPD_WHITE);

  /* all the page object need to be redisplayed */
  /* but no problem to reset all the objects */
  for(uint8_t i = 0; i<objectCount; i++) {
    displayList[i].object->reset();
  }
}

void ScreenScheduler::nextPage(void) {
  
  uint8_t newPage = currentPage + 1;
  if( newPage > endPage ) {
    newPage = 0;
  }

  setPage(newPage);
}
 
void ScreenScheduler::previousPage(void) {
  
  uint8_t newPage = currentPage - 1;
  if( newPage < 0 ) {
    newPage = endPage;
  }

  setPage(newPage);
} 


void MultiDisplay::displayStep(void) {

  if (lastFreqUpdate == 0) lastFreqUpdate = millis();
  unsigned long FreqDuration = millis() - lastFreqUpdate;
  if( FreqDuration > 1000 ) {
    lastFreqUpdate = millis();

    for(uint8_t i = 0; i<multiObjectCount; i++) {
      multiDisplayList[i].countTime--;
      if (multiDisplayList[i].countTime <= 0) {
         multiDisplayList[i].countTime = multiDisplayList[i].seconde;
         multiDisplayList[i].oldDisplayActif = multiDisplayList[i].displayActif;
         multiDisplayList[i].displayActif++;
         if (multiDisplayList[i].displayActif > multiObjectCount) multiDisplayList[i].displayActif = 0;
		 
#ifdef SCREEN_DEBUG
		 SerialPort.print("old display  : ");
         SerialPort.println(objectCount);
#endif //SCREEN_DEBUG
		 
         displayList[multiDisplayList[i].objectList[multiDisplayList[i].oldDisplayActif]].actif = false;       
         displayList[multiDisplayList[i].objectList[multiDisplayList[i].displayActif]].actif = true;  
 /*        displayList[8].actif = false;       
         displayList[9].actif = true;  */
		 
	  }		 
    }
  }
}
